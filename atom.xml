<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SunJun</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2020-01-03T09:35:02.420Z</updated>
  <id>/</id>
  
  <author>
    <name>SunJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见web服务攻击和防御手段</title>
    <link href="/2019/11/04/2019-11-04-common_means_web_attack/"/>
    <id>/2019/11/04/2019-11-04-common_means_web_attack/</id>
    <published>2019-11-04T08:50:00.000Z</published>
    <updated>2020-01-03T09:35:02.420Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;常见web服务攻击和防御手段&quot;&gt;&lt;a href=&quot;#常见web服务攻击和防御手段&quot; class=&quot;headerlink&quot; title=&quot;常见web服务攻击和防御手段&quot;&gt;&lt;/a&gt;常见web服务攻击和防御手段&lt;/h1&gt;&lt;h2 id=&quot;XSS跨站脚本攻击&quot;&gt;&lt;a
        
      
    
    </summary>
    
      <category term="network-security" scheme="/categories/network-security/"/>
    
    
      <category term="web" scheme="/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Go源码阅读-私有库拉取问题</title>
    <link href="/2019/10/29/2019-10-29-go-primary-repo/"/>
    <id>/2019/10/29/2019-10-29-go-primary-repo/</id>
    <published>2019-10-29T06:24:30.000Z</published>
    <updated>2020-01-03T09:35:02.381Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;go-get拉取私有库报错&quot;&gt;&lt;a href=&quot;#go-get拉取私有库报错&quot; class=&quot;headerlink&quot; title=&quot;go get拉取私有库报错&quot;&gt;&lt;/a&gt;go get拉取私有库报错&lt;/h2&gt;&lt;h3 id=&quot;http拉取问题-gt-1-6&quot;&gt;&lt;a
        
      
    
    </summary>
    
      <category term="golang" scheme="/categories/golang/"/>
    
    
      <category term="golang" scheme="/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Rabin-Karp在golang中的实现</title>
    <link href="/2019/09/26/2019-09-26-rabin-karp/"/>
    <id>/2019/09/26/2019-09-26-rabin-karp/</id>
    <published>2019-09-26T04:01:30.000Z</published>
    <updated>2020-01-03T09:35:02.437Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Rabin-Karp&lt;/code&gt;字符串快速查找算法和&lt;code&gt;FNV
        
      
    
    </summary>
    
      <category term="golang" scheme="/categories/golang/"/>
    
    
      <category term="golang" scheme="/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>go平滑重启选型和项目实践</title>
    <link href="/2019/09/17/2019-09-17-graceful-reload/"/>
    <id>/2019/09/17/2019-09-17-graceful-reload/</id>
    <published>2019-09-17T13:38:00.000Z</published>
    <updated>2020-01-03T09:35:02.445Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;什么是平滑重启&quot;&gt;&lt;a href=&quot;#什么是平滑重启&quot; class=&quot;headerlink&quot; title=&quot;什么是平滑重启&quot;&gt;&lt;/a&gt;什么是平滑重启&lt;/h2&gt;&lt;p&gt;当线上代码需要更新时,我们平时一般的做法需要先关闭服务然后再重启服务.
        
      
    
    </summary>
    
      <category term="golang" scheme="/categories/golang/"/>
    
    
      <category term="golang" scheme="/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="/2019/09/17/2018-04-25-java_classloader/"/>
    <id>/2019/09/17/2018-04-25-java_classloader/</id>
    <published>2019-09-17T13:17:33.000Z</published>
    <updated>2020-01-03T09:55:50.150Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;layout: post&lt;br&gt;title: “Java类加载器”&lt;br&gt;description: “Java类加载器”&lt;br&gt;tag: “classloader”&lt;br&gt;date: “2018-04-25 00:00:00 +0800”&lt;/p&gt;
&lt;h2 id=&quot;categories-“java”&quot;&gt;&lt;a href=&quot;#categories-“java”&quot; class=&quot;headerlink&quot; title=&quot;categories: “java”&quot;&gt;&lt;/a&gt;categories: “java”&lt;/h2&gt;&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;最初为了满足Java Applet的需要而被开发出来的，Java Applet 需要从远程下载Java类到浏览器执行，现在Web容器和OSGi中得到了广泛的使用。类加载器负责读取 Java 字节代码，并转换&lt;br&gt;成 java.lang.Class 类的实例。每个 java.lang.Class 实例用来表示一个Java类，通过 newInstance() 创建该类对象，newInstance()只能调用无参构造器。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="/2019/09/17/2018-02-01-win_ics/"/>
    <id>/2019/09/17/2018-02-01-win_ics/</id>
    <published>2019-09-16T16:33:58.000Z</published>
    <updated>2020-01-03T09:55:50.209Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;layout: post&lt;br&gt;title: “windows ICS”&lt;br&gt;description: “”&lt;br&gt;tag: “windows”&lt;br&gt;date: “2018-02-01 00:00:00 +0800”&lt;/p&gt;
&lt;h2 id=&quot;categories-“system”&quot;&gt;&lt;a href=&quot;#categories-“system”&quot; class=&quot;headerlink&quot; title=&quot;categories: “system”&quot;&gt;&lt;/a&gt;categories: “system”&lt;/h2&gt;&lt;h3 id=&quot;什么是windows-ICS&quot;&gt;&lt;a href=&quot;#什么是windows-ICS&quot; class=&quot;headerlink&quot; title=&quot;什么是windows ICS&quot;&gt;&lt;/a&gt;什么是windows ICS&lt;/h3&gt;&lt;p&gt;全称windows internet connect sharing,用于在电脑两个网卡之间共享网络，让windows主机成实现一个&lt;br&gt;简单的路由功能。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="/2019/09/17/2018-10-09-sputnik/"/>
    <id>/2019/09/17/2018-10-09-sputnik/</id>
    <published>2019-09-16T16:33:58.000Z</published>
    <updated>2020-01-03T09:55:50.212Z</updated>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;layout: post&lt;br&gt;title: “互联网编年史-sputnik”&lt;br&gt;description: “互联网编年史-sputnik”&lt;br&gt;tag: “sputnik”&lt;br&gt;date: “2018-10-09 00:00:00 +0800”&lt;/p&gt;
&lt;h2 id=&quot;categories-“net”&quot;&gt;&lt;a href=&quot;#categories-“net”&quot; class=&quot;headerlink&quot; title=&quot;categories: “net”&quot;&gt;&lt;/a&gt;categories: “net”&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;第一颗人造卫星的发射成功，直接导致了冷战时期美俄两国的太空竞赛&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;1957年苏联发射了人类第一颗人造卫星”Sputnik”。&lt;/p&gt;
&lt;p&gt;&amp;emsp;在Sputnik进入太空之后的60年间，人造卫星在&lt;code&gt;科学、军事和民生&lt;/code&gt;等各个方面都获得了极其广泛的应用，对人类&lt;code&gt;通讯方式带来了颠覆性的影响，揭开并深化了冷战，催生了互联网&lt;/code&gt;，&lt;br&gt;进而彻底改变了人们认识自我、观看世界的方式。&lt;br&gt;&lt;img src=&quot;https://olef5l6y5.qnssl.com/sptnik.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git workflow</title>
    <link href="/2018/08/21/2018-08-21-git_workflow/"/>
    <id>/2018/08/21/2018-08-21-git_workflow/</id>
    <published>2018-08-21T09:30:00.000Z</published>
    <updated>2020-01-03T09:35:02.423Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Git与SVN的比较&quot;&gt;&lt;a href=&quot;#Git与SVN的比较&quot; class=&quot;headerlink&quot; title=&quot;Git与SVN的比较&quot;&gt;&lt;/a&gt;Git与SVN的比较&lt;/h3&gt;&lt;h4 id=&quot;原理上&quot;&gt;&lt;a href=&quot;#原理上&quot; class=&quot;headerlink&quot; title=&quot;原理上&quot;&gt;&lt;/a&gt;原理上&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Git直接记录文件快照，SVN每次提交记录哪些文件更新更新了哪些行&lt;/li&gt;
&lt;li&gt;Git有本地仓库，SVN没有本地仓库&lt;/li&gt;
&lt;li&gt;Git大多数是本地操作，SVN大多数操作需要联网&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;操作上&quot;&gt;&lt;a href=&quot;#操作上&quot; class=&quot;headerlink&quot; title=&quot;操作上&quot;&gt;&lt;/a&gt;操作上&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Git先提交到本地仓库然后推送到远程仓库，SVN直接推送到远程仓库&lt;/li&gt;
&lt;li&gt;Git有各种”反悔”指令，SVN没有&lt;/li&gt;
&lt;li&gt;Git有真正的branch，而SVN只是工作空间的副本&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="vcs" scheme="/categories/vcs/"/>
    
    
      <category term="git" scheme="/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于TCP那些事（二）</title>
    <link href="/2018/08/20/2018-08-20-something_about_tcp2/"/>
    <id>/2018/08/20/2018-08-20-something_about_tcp2/</id>
    <published>2018-08-19T17:20:00.000Z</published>
    <updated>2020-01-03T09:55:50.201Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP重传机制&quot;&gt;&lt;a href=&quot;#TCP重传机制&quot; class=&quot;headerlink&quot; title=&quot;TCP重传机制&quot;&gt;&lt;/a&gt;TCP重传机制&lt;/h3&gt;&lt;p&gt;TCP确认机制属于累积确认，接收端给发送端的Ack确认只会确认最后一个连续的包，&lt;strong&gt;SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，&lt;br&gt;不然发送端就以为之前的都收到了&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="net" scheme="/categories/net/"/>
    
    
      <category term="tcp" scheme="/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>关于TCP那些事（一）</title>
    <link href="/2018/08/19/2018-08-19-something_about_tcp1/"/>
    <id>/2018/08/19/2018-08-19-something_about_tcp1/</id>
    <published>2018-08-19T15:20:00.000Z</published>
    <updated>2020-01-03T09:55:50.256Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TCP头格式&quot;&gt;&lt;a href=&quot;#TCP头格式&quot; class=&quot;headerlink&quot; title=&quot;TCP头格式&quot;&gt;&lt;/a&gt;TCP头格式&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://olef5l6y5.qnssl.com/tcp_head.png&quot; alt&gt;&lt;br&gt;&lt;img src=&quot;https://olef5l6y5.qnssl.com/tcp_options.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;需要注意的几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP包没有IP地址，那是IP层的事。只有源端口和目标端口。&lt;/li&gt;
&lt;li&gt;一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sequence Number&lt;/strong&gt;是包的序号，用来解决网络包乱序（reordering）问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Acknowledgement Number&lt;/strong&gt;就是ACK——用于确认收到，用来解决不丢包的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Window又叫Advertised-Window&lt;/strong&gt;，也就是著名的滑动窗口（Sliding Window），&lt;strong&gt;用于解决流控&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCP Flag&lt;/strong&gt;，包类型，&lt;strong&gt;用于控制TCP状态机&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="net" scheme="/categories/net/"/>
    
    
      <category term="tcp" scheme="/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>突破算法之-排列组合</title>
    <link href="/2018/08/19/2018-08-19-permutation_algorithms/"/>
    <id>/2018/08/19/2018-08-19-permutation_algorithms/</id>
    <published>2018-08-18T18:00:00.000Z</published>
    <updated>2020-01-03T09:55:50.223Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h3&gt;&lt;p&gt;思路是开一个数组，其下标表示1到n个数，数组元素的值为1表示其下标代表的数被选中，为0则没选中。&lt;br&gt;首先初始化，将数组前m个元素置1，表示第一个组合为前m个数。然后从左到右扫描数组元素值的”10”组合，找到第一个”10”组合后将其变为&lt;br&gt;“01”组合，同时将其左边的所有”1”全部移动到数组的最左端。当第一个”1”移动到数组的m-n的位置，即n个”1”全部移动到最右端时，就得到了最后一个组合。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithms" scheme="/categories/algorithms/"/>
    
    
      <category term="permutation" scheme="/tags/permutation/"/>
    
  </entry>
  
  <entry>
    <title>突破算法之-快速排序</title>
    <link href="/2018/08/19/2018-08-1-quick_sort/"/>
    <id>/2018/08/19/2018-08-1-quick_sort/</id>
    <published>2018-08-18T17:30:00.000Z</published>
    <updated>2020-01-03T09:55:50.253Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法原理&quot;&gt;&lt;a href=&quot;#算法原理&quot; class=&quot;headerlink&quot; title=&quot;算法原理&quot;&gt;&lt;/a&gt;算法原理&lt;/h3&gt;&lt;p&gt;快速排序是图灵奖得主&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE&quot; target=&quot;_blank&quot;&gt;C.R.A. Hoare&lt;/a&gt;与1960年提出的一种&lt;br&gt;划分交换排序，它采用了一种分治策略。&lt;br&gt;分治法的基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。&lt;br&gt;
    
    </summary>
    
      <category term="algorithms" scheme="/categories/algorithms/"/>
    
    
      <category term="sort" scheme="/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>突破算法之-二分插入排序</title>
    <link href="/2018/08/19/2018-08-19-binary_insertion_sort/"/>
    <id>/2018/08/19/2018-08-19-binary_insertion_sort/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2020-01-03T09:35:02.409Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;二分插入排序原理&quot;&gt;&lt;a href=&quot;#二分插入排序原理&quot; class=&quot;headerlink&quot; title=&quot;二分插入排序原理&quot;&gt;&lt;/a&gt;二分插入排序原理&lt;/h3&gt;&lt;p&gt;二分法是对直接插入的改进，由直接插入排序的循环遍历找出插入点改为二分法找出插入点，时间复杂度O(nlogn)。&lt;br&gt;
    
    </summary>
    
      <category term="algorithms" scheme="/categories/algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>突破算法之-希尔排序</title>
    <link href="/2018/08/18/2018-08-18-shell_sort/"/>
    <id>/2018/08/18/2018-08-18-shell_sort/</id>
    <published>2018-08-18T12:24:00.000Z</published>
    <updated>2020-01-03T09:55:50.263Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法要点&quot;&gt;&lt;a href=&quot;#算法要点&quot; class=&quot;headerlink&quot; title=&quot;算法要点&quot;&gt;&lt;/a&gt;算法要点&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是对直接插入排序算法的一种优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该方法因DL．Shell于1959年提出而得名。&lt;/p&gt;
&lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思想&lt;/h3&gt;&lt;p&gt;它的作法不是每次一个元素挨一个元素的比较。而是初期选用大跨步（增量较大）间隔比较，使记录跳跃式接近它的排序位置；&lt;br&gt;然后增量缩小；最后增量为 1 ，这样记录移动次数大大减少，提高排序效率。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithms" scheme="/categories/algorithms/"/>
    
    
      <category term="sort" scheme="/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>突破算法之-直接插入排序</title>
    <link href="/2018/08/17/2018-08-17-insertion_sort/"/>
    <id>/2018/08/17/2018-08-17-insertion_sort/</id>
    <published>2018-08-17T06:30:00.000Z</published>
    <updated>2020-01-03T09:55:50.175Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;直接插入排序原理&quot;&gt;&lt;a href=&quot;#直接插入排序原理&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序原理&quot;&gt;&lt;/a&gt;直接插入排序原理&lt;/h3&gt;&lt;p&gt;插入排序与选择排序最大的不同在于维护有序列的方式不同： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择排序通过从无序列中找出最大或最小值放在有序列尾，直到循环到最后一个元素整个数组有序  &lt;/li&gt;
&lt;li&gt;插入排序是依次把无序列中元素从有序列尾开始比较插入第一个比它小的或者比它大的元素后面，直到循环到最后一个元素整个序列有序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://olef5l6y5.qnssl.com/insertion_sort.gif&quot; alt&gt;  &lt;/p&gt;
    
    </summary>
    
      <category term="algorithms" scheme="/categories/algorithms/"/>
    
    
      <category term="algorithms" scheme="/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>突破算法之-冒泡排序</title>
    <link href="/2018/08/17/2018-08-17-bubble_sort/"/>
    <id>/2018/08/17/2018-08-17-bubble_sort/</id>
    <published>2018-08-17T05:30:00.000Z</published>
    <updated>2020-01-03T09:35:02.399Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冒泡排序原理&quot;&gt;&lt;a href=&quot;#冒泡排序原理&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序原理&quot;&gt;&lt;/a&gt;冒泡排序原理&lt;/h3&gt;&lt;p&gt;对数组内所有n个元素依次进行比较和交换位置，较大的元素往上浮较小的元素往下沉，外层进行n-1次循环后数组会从小到大排好序，&lt;br&gt;时间复杂度O(n^2)。&lt;img src=&quot;https://olef5l6y5.qnssl.com/bubble_sort.gif&quot; alt&gt;&lt;br&gt;
    
    </summary>
    
      <category term="algorithms" scheme="/categories/algorithms/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP幂等性</title>
    <link href="/2018/07/16/2018-07-16-http_idempotence/"/>
    <id>/2018/07/16/2018-07-16-http_idempotence/</id>
    <published>2018-07-15T16:00:00.000Z</published>
    <updated>2020-01-03T09:55:50.302Z</updated>
    
    <summary type="html">
    
      HTTP幂等性
    
    </summary>
    
      <category term="net" scheme="/categories/net/"/>
    
    
      <category term="http" scheme="/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>mysql8.0.11精简版</title>
    <link href="/2018/04/20/2018-04-20-mysql_8011/"/>
    <id>/2018/04/20/2018-04-20-mysql_8011/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2020-01-03T09:55:50.228Z</updated>
    
    <summary type="html">
    
      mysql8.0.11精简版
    
    </summary>
    
      <category term="db" scheme="/categories/db/"/>
    
    
      <category term="mysql" scheme="/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java 内存可见性与指令重排</title>
    <link href="/2018/04/20/2018-04-20-java_volatile/"/>
    <id>/2018/04/20/2018-04-20-java_volatile/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2020-01-03T09:55:50.165Z</updated>
    
    <summary type="html">
    
      Java 内存可见性与指令重排
    
    </summary>
    
      <category term="java" scheme="/categories/java/"/>
    
    
      <category term="volatile" scheme="/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>mysql bin/redo log顺序一致性问题</title>
    <link href="/2018/04/13/2018-04-13-mysql_tow_phase_commit/"/>
    <id>/2018/04/13/2018-04-13-mysql_tow_phase_commit/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2020-01-03T09:55:50.160Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么mysql既有bin-log也有redo-log&quot;&gt;&lt;a href=&quot;#为什么mysql既有bin-log也有redo-log&quot; class=&quot;headerlink&quot; title=&quot;为什么mysql既有bin log也有redo log&quot;&gt;&lt;/a&gt;为什么mysql既有bin log也有redo log&lt;/h3&gt;&lt;p&gt;bin log是属于mysql server层的log，主要是用来做&lt;strong&gt;主从复制和即时点恢复&lt;/strong&gt;时使用的，&lt;strong&gt;redo log是InnoDB存储引擎层的，用来保证事务安全&lt;/strong&gt;。&lt;br&gt;不管用哪种存储引擎都有bin log，而redo log只有InnoDB有，这是由mysql体系架构决定的。&lt;/p&gt;
    
    </summary>
    
      <category term="db" scheme="/categories/db/"/>
    
    
      <category term="mysql" scheme="/tags/mysql/"/>
    
  </entry>
  
</feed>
